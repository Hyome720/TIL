# 데이터 구조



## 활용

- 클래스 내부에 정의한 함수
- 객체의 기능
- <span style="color:blue">데이터 구조</span>.<span style="color:red">메서드()</span> 형태로 활용

```python
List.append(10) # 리스트에 요소 붙이기
String.split() # 나누기
```



## 파이썬 공식 문서의 표기법(배커스-나우르 표기법)

- 언어의 문법을 수학적인 수식으로 표현
  - python 구문은 아님
- ex) str.replace(old, new, <span style="color:gray">[count]</span>)
  - old, new => 필수
  - [count] => 선택적 인자



## 문자열(String Type)

- 문자들의 나열
- 변경 불가능(immutable)
- 문자열은 작은 따옴표(')/큰 따옴표(")를 활용하여 표기

| 문법        | 설명                                      |
| ----------- | ----------------------------------------- |
| s.find(x)   | x의 첫 번째 위치를 반환. 없으면 -1을 반환 |
| s.index(x)  | x의 첫 번째 위치를 반환. 없으면 오류 발생 |
| s.isalpha() | 알파벳 문자 여부                          |
| s.isupper() | 대문자 여부                               |
| s.islower() | 소문자 여부                               |
| s.istitle() | 타이틀 형식 여부                          |

- 문자열 관련 검증 메서드
  - isdecimal()
  - isdigit()
  - isnumeric()

| 문법                              | 설명                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| s.replace(old, new, [count])      | 바꿀 대상 글자를 새로운 글자로 바꿔 반환                     |
| s.strip([chars])                  | 공백이나 특정 문자 제거                                      |
| s.split(sep = None, maxsplit = 1) | 공백이나 특정 문자 기준으로 분리                             |
| 'separator'.join([iterable])      | 구분자로 iterable을 합침                                     |
| s.capitalize()                    | 가장 첫 글자를 대문자로 변경                                 |
| s.title()                         | 문자열 내 띄어쓰기 기준으로 각 단어의 첫글자는 대문자로, 나머지는 소문자로 변환 |
| s.upper()                         | 모두 대문자로 변경                                           |
| s.lower()                         | 모두 소문자로 변경                                           |
| s.swapcase()                      | 대↔소문자 서로 변경                                          |



## 리스트(List)

- 순서가 있는 구조
- 가변 자료형(mutable)

| 문법                   | 설명                                                         |
| ---------------------- | ------------------------------------------------------------ |
| L.append(x)            | 리스트 마지막에 항목 x 추가                                  |
| L.insert(i, x)         | 리스트 인덱스 i에 항목 x 삽입                                |
| L.remove(x)            | 리스트 첫 번째 x 제거<br />항목이 존재하지 않을 경우 ValueError |
| L.pop()                | 리스트 마지막 항목 반환 후 제거                              |
| L.pop(i)               | 리스트 인덱스 i에 있는 항목 반환 후 제거                     |
| L.extend(m)            | 순회형 m의 모든 항목들을 리스트 끝에 추가                    |
| L.index(x, start, end) | 리스트에 있는 항목 중 첫 번째 항목 x의 인덱스를 반환         |
| L.reverse()            | 리스트 거꾸로 정렬                                           |
| L.sort()               | 리스트 정렬                                                  |
| L.count(x)             | 리스트에서 항목 x의 갯수 반환                                |



# 튜플(Tuple)

- 순서가 있는 구조
- 불변 자료형(immutable)
  - 값에 영향을 미치지 않는 메서드만 지원
  - 대부분 리스트의 메서드와 동일



# 셋(Set)

- 순서가 없는 구조
  - 인덱스를 이용한 접근 불가
- 중복되는 요소가 없음
- 집합 연산이 가능
- 가변 자료형(mutable)

| 문법            | 설명                                                         |
| --------------- | ------------------------------------------------------------ |
| s.copy()        | 셋의 얕은 복사본 반환                                        |
| s.add(x)        | 항목 x가 셋 s에 없다면 추가                                  |
| s.pop()         | 셋 s에서 랜덤 항목을 반환하고 해당 항목을 제거<br />set이 비어 있을 경우 KeyError |
| s.remove(x)     | 항목 x를 셋 s에서 삭제<br />항목이 존재하지 않을 경우 KeyError |
| s.discard(x)    | 항목 x가 셋 s에 있는 경우 항목 x를 셋 s에서 삭제             |
| s.update(t)     | 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가             |
| s.clear()       | 모든 항목을 제거                                             |
| s.isdisjoint(t) | 셋 s가 셋 t와 서로 같은 항목을 하나라도 갖고 있지 않은 경우 True 반환 |
| s.issubset(t)   | 셋 s가 셋 t의 하위 셋인 경우 True 반환                       |
| s.issuperset(t) | 셋 s가 셋 t의 상위 셋인 경우 True 반환                       |



# 딕셔너리(Dictionary)

- 키 - 값 쌍으로 이루어진 자료형 
  - 3.7 이후 ordered
  - 이하 버전은 unordered
- key는 변경 불가능(immutable)한 데이터만 활용가능
  - string, integer, float, boolean, tuple, range
- value는 어떤 형태든 관계 없음

| 문법              | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| d.clear()         | 모든 항목을 제거                                             |
| d.copy()          | 딕셔너리 d의 얕은 복사본 반환                                |
| d.keys()          | 딕셔너리 d의 모든 키를 담은 뷰 반환                          |
| d.values()        | 딕셔너리 d의 모든 값을 담은 뷰 반환                          |
| d.items()         | 딕셔너리 d의 모든 키-값 쌍을 담은 뷰 반환                    |
| d.get(k)          | 키 k의 값을 반환하는데 키 k가 딕셔너리 d에 없을 경우 None 반환 |
| d.get(k, v)       | 키 k의 값을 반환하는데 키 k가 딕셔너리 d에 없을 경우 v 반환  |
| d.pop(k)          | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제<br />키 k가 딕셔너리 d에 없을 경우 KeyError 발생 |
| d.pop(k, v)       | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제<br />키 k가 딕셔너리 d에 없을 경우 v 반환 |
| d.update([other]) | 딕셔너리 d의 값을 매핑하여 업데이트                          |



# 복사

## 할당(assingment)

- 대입 연산자 (=)
- 해당 객체에 대한 객체 참조를 복사
- 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향



## 얕은 복사(shallow copy)

- Slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소)
- ※ 1차원적인 참조만 복사해오지 않음
  - 참조가 여러번 된다면 결과를 복사해옴


```python
lst = [[a ,b, c], 2, 3]
# lst2 = lst => 주소 복사
lst2 = lst[:] # 값만 복사 (only 1 depth)

lst[0] = [a, e, d] # lst2 변화 x
lst[0][0] = e	   # lst2 변화 o
```



## 깊은 복사(deep copy)

